---
title: 《Unity主程手记》摘要记录(3)
tags: ["技巧","摘要"]
---

## 第五章-3D模型与动画

### 5.1美术资源规范

模型面数并非越多越好，应该在一定数量下尽最大努力做大最好的美化。贴图同理。在性能和效果间取得平衡，规范可以防止制作美术资源时过度扩张。

### 5.1.1确定大小

影响因素：Mesh数量、贴图大小、骨骼和粒子数量、材质数量等。

1. 根据场景确定。
   - 强调单一主角的场景，要求可以放宽，这类游戏的全部或者大量资源全部都要服务于主角，比如汤姆猫。
   - 卡牌策略类，场景固定，视角不移动。主要资源集中在场景和人物，特效上。因为同屏模型数量不会很多，因此标准也可以宽松一些。
   - 第三人称视角RPG，视角更广，看到的模型更多。对于开放世界的建筑模型，可以按大中小分类，每种类型的建筑模型要求不同的面数（7000/5000/3000），角色主贴图和副贴图的尺寸大小也要做相应限制，比如512x512和256x256。而小型部件要控制的更小。
   - 塔防、战争类游戏，比如部落冲突或者一些比较精致的SLG，俯视视角，同屏模型数量较多（部队，主城）。对每个模型的分配资源数量限制都要小一点。
   - 其他大型游戏除了定制规范外还需要一些别的手段做优化（LOD，AOI，动态加载和卸载，流程设计等）。
2. 反推
   - 当一些模型差异大，无法通过标准统一，可以通过控制场景总面数来控制。比如场景总面数的上限要求在40万面，对场景中的每个元素进行规定，比如主角3000面，其他NPC相对少一些，高精细度的建筑物多分配一些，小物体少分配一些。贴图也可以用这样的方式来处理。规定一个内存上限，通常包括资源内存，业务代码分配，引擎运行时候占用，插件等。可以拿一些流行设备或者通用性比较强的设备作为标准参考。最关心的是资源内存，一般占用总体的80%左右。
3. 自动检测
   - 压力测试
   - 一位追求速度的情况下只好在上线前做一波优化，或者上线以后再说。
   - 工具

```C#
[MenuItem("校验工具/角色、模型、地形Prefab")]
static public void ModelPrefabValidate()
{
	//写入csv日志
    StreamWriter sw = new StreamWriter("模型Prefab检测报告.csv", false, System.Text.Encoding.UTF8);

    string[] allAssets = AssetDatabase.GetAllAssetPaths();
	foreach (string s in allAssets)
    {
    	if (UIAssetPost.IsInPath(s, ModelFbxAssetPost.Character_Prefab_path)
    		)
    	{
			GameObject obj = AssetDatabase.LoadAssetAtPath(s, typeof(GameObject)) as GameObject;

            //--检查Fbx，网格，设置
        	MeshFilter[] meshes = obj.GetComponentsInChildren<MeshFilter>();
        	if (meshes != null)
        	{
            	int vertexCount_sum = 0;

            	for(int i = 0 ; i < meshes.Length ; i++)
            	{
            		Mesh mesh = meshes[i].sharedMesh;
            		SkinnedMeshRenderer smr = meshes[i].GetComponent<SkinnedMeshRenderer>();
            		// BatchRenderer br = meshes[i].GetComponent<BatchRenderer>();

            		if(mesh == null)
            		{
            			str_record = string.Format("丢失Mesh ,{0} ,{1}", s, meshes[i].name);
            		}
            		else
            		{
	            		ModelImporter model_importer = null;
	            		string path_obj = null;
	            		UnityEngine.Object obj_fbx = null;

            			//检查fbx路径
            			path_obj = AssetDatabase.GetAssetPath(mesh);
            			obj_fbx = AssetDatabase.LoadAssetAtPath(path_obj, typeof(GameObject));

            			//检查fbx设置
            			model_importer = AssetImporter.GetAtPath(path_obj) as ModelImporter;
            			if(!model_importer.optimizeMesh)
            			{
            				str_record = string.Format("Fbx设置中 optimizeMesh off 没开起来 ,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(model_importer.importMaterials)
            			{
            				str_record = string.Format("Fbx设置中 importMaterials on 被开起来了 ,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(!model_importer.weldVertices)
            			{
            				str_record = string.Format("Fbx设置中 weldVertices off 没开起来 ,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(model_importer.importTangents != ModelImporterTangents.None)
            			{
            				str_record = string.Format("Fbx设置中 importTangents on 被开起来了 ,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(model_importer.importNormals != ModelImporterNormals.Import)
            			{
            				str_record = string.Format("Fbx设置中 importNormals off 没开起来 ,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(smr != null
            				&& model_importer.isReadable)
            			{
            				str_record = string.Format("Fbx设置中 isReadable on 开起来了 SkinnedMeshRenderer 即动画不能开write ,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(!path_obj.Contains("_write")
            				&& model_importer.isReadable)
            			{
            				str_record = string.Format("Fbx设置中 isReadable on 开起来了 但文件名没有 _write 后缀,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			if(path_obj.Contains("_write")
            				&& !model_importer.isReadable)
            			{
            				str_record = string.Format("Fbx设置中 isReadable off 没开起来 但文件名有 _write 后缀,{0} ,{1}", path_obj, obj_fbx.name);
            			}
            			vertexCount_sum += mesh.vertexCount;
            		}
            	}

            	if(vertexCount_sum > MESH_VERTEX_MAX)
        		{
        			str_record = string.Format("网格顶点数大于 {0},{1} ,{2}", MESH_VERTEX_MAX, s, vertexCount_sum);
        		}
        	}

        	...

			//检测命名是否合法
			if (!UIAssetPost.IsFileNameLegal(s))
			{
				str_record = string.Format("文件命名不合法, {0}", s);
			}
			...
    	}
	}
	...
}
```

4. 借助第三方，比如UWA

### 5.2模型合并

#### Animation or Animator？

Unity已经不再对Animation进行维护。同时在性能上，Animator要优于Animation，且Animator的功能更多。

#### SubMesh

多个网格组成一个模型，一个网格也可以由多个子网格组成。

引擎运行时子网格也需要匹配一个材质球来渲染，网格可以拆分成多个子网格，也可以将多个子网格合并成一个网格。

***为什么要制作子网格？***

需要表现多种不同效果，比如一部分网格用A材质球表现，一份网格用B材质球表现；单独拆出一个部分网格用于使用频率较高的公共材质，减少重复劳动；复杂动画的情况下，出于性能考虑，拆出一部分模型，让他们单独成为模型动画的一部分。

缺点：DrawCall问题，可能会打断合批。

#### 动态合并

将拥有相同材质的模型合并成一个模型和一个材质，从而减少向GPU的次数。

- 动态合批

  顶点数小于900；如果shader使用了法线，顶点坐标，独立UV，那么要小于300个。

  合批物体的缩放比例要保持一致

  材质球必须一样

  多管线着色器会打断合批

  支持多灯光的前置渲染无法合批

  内置管线中的延迟渲染关闭了动态合批，因为他需要画两次

  所有多Pass的shader增加了渲染管道，不会动态合批

动态合批会消耗CPU将物体的顶点变换到世界空间。

要注意合批的开销和带来的性能提升，无脑合批并不是万能的。

 - 静态合批

   让引擎在离线状态下进行合批，将所有参与合批的物体放入世界空间，以材质球为分类标准分别合并，构建一个顶点和索引缓存，所有可见的物体就会被同一批drawCall提交，但消耗了更多内存。

   要参与静态合批的物体需要勾选static。

   本质上来说，静态合批并没有节省drawCall数量，而是减少了图形接口的状态转变带来的损耗。多数平台上批处理被限制在64000个顶点和64000个索引数量内（OpenGLES要求48000，MacOs要求32000）

总结一下，动态合批要求使用同一个材质，对顶点数量也有要求，缩放比例要一致，不能用多通道的shader。静态合批要求物体必须为static，不能移动旋转缩放，不能带动画。

动态合批规则多，静态合批限制大。在某些情况下可以自己手动实现模型合并。

#### 模型合并程序

Mesh.CombineMeshes合并网格

MeshFilter类，保存网格数据

MeshRender类，网格绘制类型

*“mesh和material都是实例型的变量，对mesh和material执行任何操作，都是额外复制一份后再重新赋值，即使只是get操作，也同样会执行复制操作。也就是说，对mesh和material进行操作后，就会变成另外一个实例，虽然看上去一样，但其实已是不同的实例了。sharedMesh和sharedMaterial与前面两个变量不同，它们是共享型的。多个3D模型可以共用同一个指定的sharedMesh和sharedMaterial，当你修改sharedMesh或sharedMaterial里面的参数时，指向同一个sharedMesh和sharedMaterial的多个模型就会同时改变效果。也就是说，sharedMesh和sharedMaterial发生改变后，所有使用sharedMesh和sharedMaterial资源的3D模型都会表现出相同的效果。”*

**网格、MeshFilter和MeshRender**：XXX.fbx，其中存储了顶点，UV，顶点颜色，三角形，切线法线，骨骼权重等数据。网格被实例化后存储在MeshFilter内，其中包含mat和sharedMat两种了类型变量。MeshRender会获取MeshFilter中的数据进行渲染。

**CombineInstance**：合并数据实例类型。合并时为每个要参与合并的网格创建一个该类型的实例，放入必要数据（Mesh，SubMesh）索引等，然后将CombineInstance数组传给Mesh.CombineMeshes。

```c#
//建立合并数组
CombineInstance[] combine = new CombineInstance[mMeshFilter.Count];
//填入数据
for(int i = 0 ; i< mMeshFilter.Count ; i++)
{
    combine[i].mesh = mMeshFilter[i].sharedMesh;
    combine[i].transform = mMeshFilter.transform.localToWorldMatrix;
    combine[i].subMeshIndex = i;//标识Material的索引位置，可以为0，1，2等
}
//合并mesh
new_meshFilter.sharedMesh.CombineMeshes(combine);
//new_meshFilter.sharedMesh.CombineMeshes(combine,false);//也可以在合并后保留subMesh
```

### 5.3状态机

- 场景切换，可以抽象或者继承为流程类型（Procedure），将游戏划分为几个具体的阶段，比如登录阶段，预加载阶段，主游戏阶段。
- 角色行为：idle,move,die等
- 宝箱、机关等物体的动画和逻辑
- 构建AI：利用FSM可以构建一些相对简单的AI

ActorStateBase状态基类->多个子类实现->一个mgr指向当前状态并且调用相应逻辑(current,OnEnter,OnUpdate,OnLeave等)

### 5.4 3D模型变换

顶点->三角形->Meshs

索引三角形网格：顶点列表存储网格的所有顶点，索引列表存储形成三角形的索引。，每三个索引指向三个顶点，代表一个三角形。顶点除了位置信息外还包含UV，法线、切线、颜色等信息。**三角形的索引顺序为顺时针**。

CPU和GPU的传输速率问题：

 - 缓存命中：如果要传入的顶点数据已经在缓存，则直接读取，否则就读入并且放到缓存里。
 - 三角带：以共享边为依据将所有三角形排开，一个顶点加上共享边可以构成三角形。
 - 三角扇

顶点索引是主流的三角形表达方式。

将所有顶点放入一个数组vertextArr，再用另一个数组保存所有顶点的集合indexArr，indexArr的元素代表vertexArr的元素下标，每三个组成一个三角形。

(0,0,0),(0,1,0),(1,1,0),(1,0,0)构成一个矩形网格。其索引数据为0,1,2,2,3,0。即(0,0,0),(0,1,0),(1,1,0)构成一个三角形，(0,1,0),(1,1,0),(1,0,0)构成一个三角形。

*“我们再来完整地叙述一遍网格数据从制作到渲染的过程。首先，美术人员制作3D模型并导出成Unity3D能够识别的格式，即.fbx文件，其中已经包含了顶点和索引数据，然后在程序中将.fbx实例化成Unity3D的GameObject，它们身上附带的MeshFilter组件存储了网格的顶点数据和索引数据（我们也可以自己创建顶点数组和索引数组，以手动的方式输入顶点数据和索引数据，就如上文描述矩形网格那样）。MeshFilter可用于存储顶点和索引数据，MeshRender或SkinMeshRender可用于渲染模型，这些顶点数据通常都会与材质球结合，在渲染时一起送入图形卡，其中与我们预想的不一样的是，在送入时并不会由索引数据送入，而是由三个顶点一组组成的三角形顶点送入图形卡。接着由图形卡负责处理我们送入的数据，然后渲染帧缓存，并输出到屏幕。”*

#### 贴图渲染

矩形网格顶点：[（0，0，0），（0，1，0），（1，1，0），（1，0，0）]

索引集合：[0，1，2，2，3，0]

UV集合：[（0，0），（0，1），（1，1），（1，1），（1，0），（0，0）]表示两个三角形上的绘制范围。

#### 模型切割

思路：提取要切割模型的顶点数据，分成切割后的左右两部分分别存储，使用两个新的渲染组件实例处理他们，然后加入一些碰撞和物理。

顶点该放在左边还是右边，如何判断顶点是否被切割：对于一个三角网格，遍历其所有顶点，每个顶点指向切割结束位置的方向与平面法线做点乘检查方向是否一致，大于0为一侧，小于0为另一侧。如果两个顶点组成的线段在做点乘时方向结果不一致，则说明线段与切割平面相交。对于切割线和线段的交点，顶点A到顶点B的方向上取比例t即为切割点的位置，(A-B)*t+A。求出t的方法是，求顶点A到切割线的距离以及顶点B到切割线的距离，然后将结果除以顶点A到切割线的距离即可。然后进行缝合，缝合方法有好几种，可以参考这里：github.com/hugoscurti/mesh-cutter。

#### 模型扭曲

多应用于爆炸造成的地面凹陷，拉球，陶艺游戏，可拉伸的摇杆等。

思路：取出顶点数据，修改顶点位置再放回去。

- 爆炸凹陷：找出需要处理爆炸的地面网格，找到所有爆炸范围内的顶点，进行顶点凹陷计算。以经纬度来表示地面，则计算公式为x=cosacosb，y=cosasinb，z=sina。a、b为经纬度
- 球体拉伸和反弹：获取拉伸点，计算所有顶点与拉伸点的距离，距离越大偏移量越小。具体的偏移量随距离而形成一条衰减曲线，假设距离是d，拉伸的距离为f，偏移量结果为res，那么最简单的衰减公式为res=f/(d×d)。将结果乘以系数形成新的顶点坐标重新写入即可。拉伸后放开时，顶点需要回到原位置，简单的办法是缓存顶点的原位置。反弹衰减也是曲线关系，最简单的公式如res=d×d，或者更平滑点，如曲线公式res=(d/max)×(d-2)×k。
- 制陶游戏：但鼠标或手指触碰到模型时，根据方向将一定范围内的顶点向触摸方向偏移，离触摸点最近的顶点偏移最大，越远的越小。

#### 简化模型

简化模型的方法中，LOD较为常用。网格由点线面组成，减面等于减少点和线，如果简单粗暴的减少会引起模型形变而达不到LOD的目的，一个方法是将线上的两个顶点变为一个顶点。一种方案是**基于二次项误差的边收缩算法**。

#### 蒙皮骨骼

MeshRenderer和SkinnedMeshRenderer分别用于渲染模型和3D模型动画，他们的模型数据都存储在MeshFilter中。SkinnedMeshRenderer除了3D模型数据外，还会拿到骨骼数据和顶点权重数据。

MeshRender从MeshFilter中取出顶点数据、UV、颜色、法线等，结合自己的材质，发送给GPU。

SkinnedMeshRenderer也遵循同样的步骤。

模型要做动作，就要改变模型的顶点。两种方法：1、顶点动画。可以参照《戴森球计划》的优化方案。2、使用骨骼影响网格顶点，让模型形变。

https://imgse.com/i/v5pfRH

这是一个刚性层级式动画，他将模型拆成多个部位，按照层级节点的方式装上去。

![图片](https://s1.ax1x.com/2022/08/31/v5pfRH.png)

但问题是：关节连接处产生裂缝而穿帮。

蒙皮骨骼动画的数据主要由一些骨骼点和权重数据组成。游戏角色的骨骼数量通常不会超过100个。

骨骼动画由骨骼点（带有相对空间坐标点的数据实体）组成，骨骼点为树形结构，可以有许多但只能有一个根节点。父节点变换子节点跟着一起变。

*“在现代手机游戏中，每个人物骨骼动画的数量一般为30个左右，PC单机游戏中可达75个左右。骨骼数量越多，动画就越有动感，但同时也会消耗掉更多的运算量。”*

bones变量用于存储所有的骨骼点，它在蒙皮网格中以transform的形式存在。每个骨骼点都可以影响一定范围内的顶点，一个顶点也可以收到多个骨骼点的影响。每个顶点都有影响它本身最多四个的顶点权重数据，bonesWeights用于存储所有顶点的骨骼权重值。

BoneWeight.boneIndex0到3分别代表被影响的骨骼点索引，而weight0到3表示骨骼点的权重，范围0-1。骨骼移动时，就会取BoneWeight实例来计算收到影响顶点的旋转、偏移和缩放。

制作蒙皮动画一般分为三步：使用建模软件（3DMAX,Maya等）构建一系列骨骼点->动画师通过模型软件制作动画导出到引擎的动画文件格式比如unity的fbx->Unity导入后直接调用相关api播放即可。

```c#
//新建个动画组件和蒙皮组件
gameObject.AddComponent<Animation>();
gameObject.AddComponent<SkinnedMeshRenderer>();
SkinnedMeshRenderer rend = GetComponent<SkinnedMeshRenderer>();
Animation anim = GetComponent<Animation>();

//新建个网格组件，并编入4个顶点形成一个矩形形状的网格
Mesh mesh = new Mesh();
mesh.vertices = new Vector3[] {new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(-1, 5, 0), new Vector3(1, 5, 0)};
mesh.uv = new Vector2[] {new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)};
mesh.triangles = new int[] {0, 1, 2, 1, 3, 2};
mesh.RecalculateNormals();

//新建个漫反射的材质球
rend.material = new Material(Shader.Find("Diffuse"));

//为每个顶点定制相应的骨骼权重
BoneWeight[] weights = new BoneWeight[4];
weights[0].boneIndex0 = 0;
weights[0].weight0 = 1;
weights[1].boneIndex0 = 0;
weights[1].weight0 = 1;
weights[2].boneIndex0 = 1;
weights[2].weight0 = 1;
weights[3].boneIndex0 = 1;
weights[3].weight0 = 1;

//把骨骼权重赋值给网格组件
mesh.boneWeights = weights;

//创建新的骨骼点，设置骨骼点的位置，父节点，和位移旋转矩阵
Transform[] bones = new Transform[2];
Matrix4x4[] bindPoses = new Matrix4x4[2];

bones[0] = new GameObject("Lower").transform;
bones[0].parent = transform;
bones[0].localRotation = Quaternion.identity;
bones[0].localPosition = Vector3.zero;
bindPoses[0] = bones[0].worldToLocalMatrix * transform.localToWorldMatrix;

bones[1] = new GameObject("Upper").transform;
bones[1].parent = transform;
bones[1].localRotation = Quaternion.identity;
bones[1].localPosition = new Vector3(0, 5, 0);
bindPoses[1] = bones[1].worldToLocalMatrix * transform.localToWorldMatrix;

mesh.bindposes = bindPoses;

//把骨骼点和网格赋值给蒙皮组件
rend.bones = bones;
rend.sharedMesh = mesh;

//定制几个关键帧
AnimationCurve curve = new AnimationCurve();
curve.keys = new Keyframe[] {new Keyframe(0, 0, 0, 0), new Keyframe(1, 3, 0, 0), new Keyframe(2, 0.0F, 0, 0)};

//创建帧动画
AnimationClip clip = new AnimationClip();
clip.SetCurve("Lower", typeof(Transform), "m_LocalPosition.z", curve);

//把帧动画赋值给动画组件，并播放动画
anim.AddClip(clip, "test");
anim.Play("test");
```

#### 换皮换装

拆分骨骼数据文件和多个模型文件，保证骨骼动画没有问题，更换模型部件带来的dc问题可以考虑Mesh.CombineMeshes合并网格。

#### 捏脸





#### 内存泄漏

程序：引用计数->互相引用，环形引用

​	Mono：逐渐抛弃。

​	IL2CPP：内存依然托管，只是由C++编写VM来接管内存，不过这个VM只是内存托管而已，并不解析和执行任何代码，只是个管理器。

资源：Native内存泄漏，加载后不释放。

​	MemoryProfiler，内存快照，需要人工比对。

​	**两种寻找资源内存泄漏的技巧：**

*“1） 通过资源名来识别。即在美术资源（如贴图、材质）命名的时候，就将其所属的游戏状态放在文件名中，如某贴图叫做bg.png，在房间中使用，则修改为Room_bg.png。这样在Profile工具里一坨内存资源里面，混入了一个Room大头的资源，可以很容易地识别出来，也方便利用程序来识别。这个方法但也不是万能的，因为在项目制作过程当中，一张图需要被用到各个场景中去，很可能也不只一两个，有时甚至四五个场景中都会用，只用前缀来代替使用场景的指定，很多时候也会造成另一种误区。甚至由于项目的复杂度扩展到一定程度，包括人员更替，在检查资源泄漏时，用前缀来判断使用场景点不太靠谱，因为你根本就不知道这张图在哪使用了。所以说技巧只能辅助你，并不是说一定能有效。”*

*“2） 我们可以通过Unity提供的接口Resources.FindObjectsOfTypeAll()进行资源的Dump.可以根据需求Dump贴图、材质、模型或其他资源类型，只需要将Type作为参数传入即可。Dump成功之后我们将这些信息结果保存成一份文本文件，这样可以用对比工具对多次Dump之后的结果进行比较，找到新增的资源，那么这些资源就是潜在的泄漏对象，需要重点追查。”*

Unity的项目优化工具：借助UWA的GOT、[内存快照比对工具](https://github.com/GameBuildingBlocks/PerfAssist/)

参考：深入浅出再谈Unity内存泄漏 作者：Arthuryu

#### 高低端机型

- UI贴图质量区分对待，不同设备分两套贴图，一套针对高端机无压缩，一套针对低端机压缩。
- 特效区分对待，低端设备减少特效、例子数量，非关键部分不显示特效。
- 阴影区分对待，针对设备不同使用不同质量或不使用阴影。
  - QualitySettings.shadowResolution 设置渲染质量，QualitySettings.shadows 设置有无和模式以及 QualitySettings.shadowProjection 投射质量，QualitySettings.shadowDistance 阴影显示距离，QualitySettings.shadowCascades 接受灯光的数量等。
  - 角色底部加一个黑色面片代替阴影。
  - 只有部分模型使用实时阴影。
- LOD、抗锯齿
- QualitySettings.masterTextureLimit等

#### 设备区分

- 硬件型号，比如一些固定版本的设备，Apple，或者一些主机，硬件是随着型号固定的，很好判断。
- 对于Android或PC这类平台，就需要综合考虑内存，CPU型号，平均帧率等。

#### GC优化

触发：1、在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；2、GC会自动的触发，不同平台运行频率不一样；3、 GC可以被强制执行。

策略：1、减少堆内存的分配和引用分配；2、降低分配和回收频率；3、测量GC和堆内存的扩展时间。

一些方案：

- 缓存变量和对象。
- 优化业务逻辑，减少逻辑调用。
- 缓存集合
- 池
- string，缓存，StringBuilder，拆分，Release版本移除Log。
- 尽量避免携程。
- 低版本的Unity注意foreach的问题。
- 尽量避免匿名函数，这会额外生成匿名类和一个静态函数。
- 尽量避免LINQ
- 在适当的时候主动发起GC，比如Preload完成，或者切换场景前后。
