---
title: 《Unity主程手记》摘要记录(3)
tags: ["技巧","摘要"]
---

作者：陆泽西-《Unity3D高级编程：主程手记》

## 第七章-AI

### 7.1状态机

State基类-管理类->子类实现_>current指向当前状态。

基本的周期函数：Enter，Update，Leave。

但是不好处理复杂AI、无法处理突发状态。

### 7.2行为树

树状节点，自由灵活。

几种典型的Node类型：

- 复合节点Composite Node，条件检查
- 修饰节点Decorator Node，可以额外处理子节点的条件结果
- 条件节点Condition Node，大于小于、距离、与或非、True/Flase
- 行为节点Action Node，执行具体的行为，一般都是最后一层的子节点。

为了提供随机性，还有非线性迭代的加权随机变种、以及调试用的Log节点等。

使用行为树可以可以将AI配置化繁为简，让一个个节点组成一套完整的AI策略。

与之相似的是**决策树**，它也是树形结构。

*“从理论上讲，决策树就是为了制定决策，而行为树是为了控制行为，它们是两个不同的理念。行为树更加注重变化，而决策树则更加注重选择。*”

除此以外还有goap等AI方案。而对于更加复杂的AI需求，则需要考虑机器学习等方法。

### 7.3 非典型性AI

#### 演算式AI

常见于页游、卡牌类游戏的自动对战，它根据一个随机种子算出正常战斗，然后将结果同步到客户端。

特点：结果确定\根据战斗进程，有时间轴的概念。

#### 博弈式AI

比如棋类游戏的AI，这类AI的目标就是击败玩家。

特点：搜索下一步可能发生的情况，以及下几步可能发生的情况，选择最优解。

## 第八章-地图与寻路

### 8.1 A星

相较于其他搜索算法如Dijkstra和Floyd，A*更加在时间和空间上的复杂度更低，前两者的时间和空间复杂度分别是O(N^2)、O(N^2)和O(N^3)和O(N^2)。而A*的平均复杂度为O(N lgN)

基本思路：以2D四边形网格地图为例，寻找自身周边点内寻路代价最小的点（重点+当前位置；当前位置+重点）。将其作为当前点直至重点。

#### 优化方案

在长距离导航的情况下，不加优化和剪枝的传统寻路算法会消耗大量计算。

优化思路有如下几个方面：

1. 离线计算已经连同可行走的常用路径，寻路时只要计算起点到离线计算路径的起点，以及离线计算路径终点到终点即可。为了让离线计算更快，可以地图上设置一些距离较近的导航爹，先做导航点寻路再取出导航点之间的数据来拼接路径。
2. 算法优化，对于open列表，每次从中寻找新的最低代价寻路点，都要排序或遍历一次，可以修改open列表为最小堆，这样根据最小堆的特性，在向open列表内插入和获取数据时，他就已经在最小的位置，无需排序和遍历。另外对于寻路期望值，也可以做一些优化。
3. 权重引导，对于网格内的可寻路点，可以加上寻路权重，在计算最小代价点时，让权重也参与运算。
4. 拆分区域，将地图分块，计算各个区域之间的路径。
5. A*的变体，比如JPS，Theta，SubGoal等。

当然以上几种思路也可以搭配使用。

### 8.2寻路网格

#### 数组构建网格





BoneWeight.boneIndex0到3分别代表被影响的骨骼点索引，而weight0到3表示骨骼点的权重，范围0-1。骨骼移动时，就会取BoneWeight实例来计算收到影响顶点的旋转、偏移和缩放。

制作蒙皮动画一般分为三步：使用建模软件（3DMAX,Maya等）构建一系列骨骼点->动画师通过模型软件制作动画导出到引擎的动画文件格式比如unity的fbx->Unity导入后直接调用相关api播放即可。

```c#
//新建个动画组件和蒙皮组件
gameObject.AddComponent<Animation>();
gameObject.AddComponent<SkinnedMeshRenderer>();
SkinnedMeshRenderer rend = GetComponent<SkinnedMeshRenderer>();
Animation anim = GetComponent<Animation>();

//新建个网格组件，并编入4个顶点形成一个矩形形状的网格
Mesh mesh = new Mesh();
mesh.vertices = new Vector3[] {new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(-1, 5, 0), new Vector3(1, 5, 0)};
mesh.uv = new Vector2[] {new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1), new Vector2(1, 1)};
mesh.triangles = new int[] {0, 1, 2, 1, 3, 2};
mesh.RecalculateNormals();

//新建个漫反射的材质球
rend.material = new Material(Shader.Find("Diffuse"));

//为每个顶点定制相应的骨骼权重
BoneWeight[] weights = new BoneWeight[4];
weights[0].boneIndex0 = 0;
weights[0].weight0 = 1;
weights[1].boneIndex0 = 0;
weights[1].weight0 = 1;
weights[2].boneIndex0 = 1;
weights[2].weight0 = 1;
weights[3].boneIndex0 = 1;
weights[3].weight0 = 1;

//把骨骼权重赋值给网格组件
mesh.boneWeights = weights;

//创建新的骨骼点，设置骨骼点的位置，父节点，和位移旋转矩阵
Transform[] bones = new Transform[2];
Matrix4x4[] bindPoses = new Matrix4x4[2];

bones[0] = new GameObject("Lower").transform;
bones[0].parent = transform;
bones[0].localRotation = Quaternion.identity;
bones[0].localPosition = Vector3.zero;
bindPoses[0] = bones[0].worldToLocalMatrix * transform.localToWorldMatrix;

bones[1] = new GameObject("Upper").transform;
bones[1].parent = transform;
bones[1].localRotation = Quaternion.identity;
bones[1].localPosition = new Vector3(0, 5, 0);
bindPoses[1] = bones[1].worldToLocalMatrix * transform.localToWorldMatrix;

mesh.bindposes = bindPoses;

//把骨骼点和网格赋值给蒙皮组件
rend.bones = bones;
rend.sharedMesh = mesh;

//定制几个关键帧
AnimationCurve curve = new AnimationCurve();
curve.keys = new Keyframe[] {new Keyframe(0, 0, 0, 0), new Keyframe(1, 3, 0, 0), new Keyframe(2, 0.0F, 0, 0)};

//创建帧动画
AnimationClip clip = new AnimationClip();
clip.SetCurve("Lower", typeof(Transform), "m_LocalPosition.z", curve);

//把帧动画赋值给动画组件，并播放动画
anim.AddClip(clip, "test");
anim.Play("test");
```

#### 换皮换装

拆分骨骼数据文件和多个模型文件，保证骨骼动画没有问题，同一套骨骼可以用于多个换装模型，更换模型部件带来的dc问题可以考虑Mesh.CombineMeshes合并网格。

#### 捏脸

更改骨骼节点的local坐标，为了防止动画数据强行恢复骨骼点，需要额外增加一些用于捏脸的骨骼点。

对于发色，眼睛颜色等，可以更换贴图，调整采样颜色。

而使用不同网格的线性插值的方案可以做面部表情。

#### 优化

SkinnedMesh动画因为每帧都要计算，实际上是比较消耗CPU的。

CPU Skinning：多线程+**SIMD**加速SkinnedMesh计算，注意SIMD并没有减少运算量，只是加快了运算速度。

- 顶点动画，把每帧的顶点位置写到文件里，给到shader，用shader做顶点位移，将计算过程从CPU转到GPU。比如风摆，旗子，水波。但是如果动画没有规律 ，较为复杂，则不适用。
- 离线加速，因为每帧改变顶点位置，可以离线准备好每帧模型的网格数据。用内存换时间。
- GPU Instancing / SRP Batcher
- LOD，

### 5.5 资源

资源卸载的空置倒计时、池。

## 第六章-网络

### 6.1TCP和UDP

TCP：面向连接，三次握手，四次挥手。

- ACK：TCP包头数据控制位，对数据进行确认
- SYN：同步序列号，建立连接时置1
- FIN：发送端完成发送任务位。

**TCP的包头结构**

UDP：非连接协议，不维护连接状态

- TCP基于连接，UDP面向无连接
- TCP资源开销多
- TCP包头大，有状态，UDP包头小，无状态
- TCP为流模式，UDP为数据报模式
- TCP可以保证数据可靠性，UDP可能丢包
- TCP保证数据连贯，UDP不保证

如果客户端间歇发起无状态的查询，并且偶尔发生的延迟可以容忍->HTTP/HTTPS

如果客户端和服务器都可以独立发包，但是偶尔发生的延迟可以容忍（比如在线的纸牌游戏、大部分MMO类游戏）->TCP/UDP

如果客户端和服务器都可以独立发包，而且无法忍受延迟（动作类游戏、MMO类游戏）->UDP

### 6.2 TCP

需要注意的点：建立连接、断线检测、协议、发送和接受缓冲队列、发送数据合并、线程死锁。

.Net的Socket网络库。

#### 线程锁

```c#
lock(obj)
{
    message_queue.push(data);
}
```

```c#
lock(obj)
{
    var data = message_queue.pop(data);
}
```

#### 缓冲队列

保证当前数据解析处理完毕，再从队列里拿下一个，没有就继续等待。

```c#
IMessage _msgCache = null;
private void Update()
{
    _msgCache = PopMsg();
    while(_msgCache != null)
    {
        //解析
    }
}
```

#### 双队列结构

为了避免线程等待和资源争夺。将收到数据的队列数据给入处理数据的队列，然后清空收到的数据队列，这样无需等待消息包的解析就可以一直接受消息。

#### 发送

发送时合并一部分数据报，提升效率。但要保证不要太大，因为失败一次就要全部重发。

#### 协议和数据定义

1. 双端都能接受的格式
2. 数据包最小化
3. 一定的校验能力
   - MD5
   - 奇偶校验
   - CRC校验
   - 加密算法（RSA，公钥私钥，非堆成加密）

#### 断线检测

心跳包，间隔发送。

### 6.3 UDP

UDP不会自己校验重发；因为数据报的关系，丢包概率大；接受顺序不确定；因为没有状态，所以没有连接断开和连接确认机制。

#### 连接确认机制

UDP自身没有三次握手的机制，但可以模拟，另外对于握手机制的第三步，其实可以省略。

```c#
//建立连接
SvrEndPoint = new IPEndPoint(IPAddress.Parse(host), port);
UdpClient = new UdpClient(host, port);
UdpClient.Connect(SvrEndPoint);
```

```c#
//启动线程接收数据
UdpClient.BeginReceive(ReceiveCallback, this);
void ReceiveCallback(IAsyncResult ar)
{
    Byte[] data = (mIPEndPoint == null) ?
        UdpClient.Receive(ref mIPEndPoint) :
        UdpClient.EndReceive(ar, ref mIPEndPoint);

    if (null != data)
        OnData(data);

    if (mUdpClient != null)
    {
        // try to receive again.
        mUdpClient.BeginReceive(ReceiveCallback, this);
    }
}

```

```c#
//握手包
SendConnectRequest();
//暂时不接收其他包知道服务器返回确认连接
StopSendNormalPackage();
StopReceiveNormalPackage();
```

`````c#
//等待连接确认
Void OnData(byte[] data)
{
     If( !IsConnected )
    {
        If( IsConnectResponse(data) )
        {
            OnEvent( Event.ConnectSuccess );
            IsConnected = true;
        }
        Return;
    }
    ProcessNormalData(data);
}

`````

#### 数据校验和重发

可以模拟TCP的Seq、Ack校验和重发机制。

#### 丢包问题

1. 异步收包导致包体丢失。
2. 发送的数据包太大，控制报文长度，让每个报文长度小于MTU
3. 发包频率太快，建立缓冲。

### 6.4封装HTTP

.Net库和Unity封装的库皆可实现（注意2018后Unity用UnityWebRequest取代了WWW）

HTTP是应用层协议，因此他要求底层协议是可靠的，它依赖于TCP，因为它本身并没有检测等机制。

```c#
void StartRequest(string url, WWWForm wwwform, Callback _callback)
{
    this.web_request = UnityWebRequest.POST(url, wwwform);
    this.Callback =  _callback;
    this.web_request.SendWebRequest();
}
void Update()
{
    if(web_request != null)
    {
        if(web_request.isDone)
        {
            ProcessResponse(web_request);
            web_request.Dispose();
            web_request = null;
        }
    }
}
```

HTTP分为header和body两部分，header包括请求方式，host等信息，body是消息体信息。以下是一个典型的HTTP服务器返回消息。

```http
    HTTP/1.1 200
    Date:Mon,31Dec200104:25:57GMT
    Server:Apache/1.3.14(Unix)
    Content-type:text/html
    Last-modified:Tue,17Apr200106:46:28GMT
    Content-length:xxx
    
    //这里HEADS 和 BODY用空行隔开
    body content
```

#### 多次和连续请求引起的问题

返回数据无法保证先后，回调不可预知。

- 多个连接发出请求后，等到所有数据都拿到后再执行逻辑
- 逐个发起，逐个处理，保证顺序
- 多连接和逐个发起混合使用

### 6.5 协议原理

典型的协议包格式包括Json，MsgPack，Protobuf，或者自定义格式。

- 自定义二进制流格式：不具备通用性，一个典型的自定义二进制流格式包括三部分： 数据大小 | 协议编号 | 具体数据

  ```c#
  class Msg
  {
      uint size;
      uint msg_id;
      byte[] datas;
  }
  ```

校验消息大小->获取消息ID->根据消息ID决定数据读取方式（比如每隔多少字节获取多少数据，转换成何种类型，由消息类型决定）

- ProtoBuf：消息定义(.proto)

  序列化和反序列化：使用协议字段后的编号作为KV的变量映射，然后在生成class时写死；反序列化：一段switch/case->switch(tag) case 1: xxx = input.ReadString(); break; case 2:xx = input.readInt32();

  使用protobuf要注意协议修改时的兼容问题，在原有协议新加字段要注意optional和repeated限定符，原有字段不要移除required等。

  但protobuf也有缺点，比如无法表达复杂结构，但在大部分情况下也已够用。

### 6.6 网络同步

状态同步、广播同步、帧同步

片面地讲，状态同步=同步数据，帧同步=同步逻辑帧数据包和指令

还有一些技术点可以看守望团队GDC2017技术分享。

#### 同步快进：

客户端卡了，堆积了过量的数据包：可以一次将缓存队列的消息包全部执行，但可能会导致卡顿。或者分批次执行固定帧。通过内存快照来进行模拟也是一种方式。

#### 精度问题

帧同步的一些逻辑放在了客户端来做，理论上来说只要所有客户端和服务器帧数保持一致，业务逻辑代码一致，就能得出一样的结果。但如果因为平台差异导致浮点数精度不一致，那么就可能出现问题，比如服务器算出来是1.0，给到客户端变成了0.999999999999。

可以用定点数，或者统一乘除小数位转换为int来解决这个问题（15.5->15.5*10000->155000）。

#### 同步锁

每个客户端间隔一定时间向服务器或主机发送心跳包，如果一人网络状态不好，则所有人等待，直到恢复。（星际1、大乱斗）
