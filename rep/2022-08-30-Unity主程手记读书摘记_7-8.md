---
title: 《Unity主程手记》摘要记录(5)
tags: ["技巧","摘要"]
---

作者：陆泽西-《Unity3D高级编程：主程手记》

## 第九章-渲染管线与图形

### 9.1数学

#### 向量的意义

**点乘**	

a·b=‖a‖×‖b‖×cosβ，结果为正数，两者方向一致；0：垂直；负数方向不一致。当负数最小，两者方向完全相反。

β=arcos((a·b)/(|a|×|b|))角度计算

````c#
//点乘
public static float Dot(Vector3 lhs,Vector3 rhs)
{
    return lhs.x*rhs.x+lhs.y*rhs.y+lhs.z*rhs.z;
}
//用Mafhf.Acos(float)取反三角函数，就有了：β = Mathf.Acos(Vector3.Dot(lhs,rhs)/(lhs.magnitude * rhs.magnitude));
````

*方向；角度；攻击范围；投影面积；cos；a在b上的投影长度占比；夹角*

**叉乘**

求得垂直于两个向量的另一条向量。

c=a×b=(a1, a2, a3)×(b1, b2, b3)=(a2×b3-a3×b3, a3×b1-a1×b3, a1×b2-a2×b1)

|c|=|a×b|=|a|×|b|×sinβ

````c#
//叉乘
public static Vector3 Cross(Vector3 lhs,Vector3 rhs)
{
    return new Vector3
        (
        	lhs.y*rhs.z - lhs.z*rhs.y,
        	lhs.z*rhs.x - lhs.x*rhs.z,
        	lhs.x*rhs.y - lhs.y*rhs.x,
    	);
}
````

*顶点坐标；切线空间；TBN矩阵；右手定则（垂直结果方向）平面法向量；左右；攻击范围*；

#### 向量之间的投影

[![xVeMGV.png](https://s1.ax1x.com/2022/09/26/xVeMGV.png)](https://imgse.com/i/xVeMGV)

向量C就是A乘以某个系数得到的，该系数可以认为是C的模除以A的模。

c=a×(|c|/|a|)	=>	

|c|=|b|×cosβ（C和B的家教β）	=>	

c=a×(|b|×cosβ/|a|)（计算投影向量C）	=>	

c=a×(|b|×cosβ/|a|)（除号的两边乘以A的模）	=>	

c=a×(a·b)/(|a|^2)（|b|×cosβ×|a|组合起来等于a向量与b向量点积的结果，于是就有了这样的的简化共识）

````c#
//将一个Vector投影到另一个Vector
//Unity中的投影函数
public static Vector3 Project(Vector3 vector, Vector3 onNormal)
{
    float sqrMag = Dot(onNormal, onNormal);
    if (sqrMag < Mathf.Epsilon)
        return zero;
    else
        return onNormal * Dot(vector, onNormal) / sqrMag;
}
````

#### 矩阵

常用矩阵：2X2 / 3X3 / 4X4

齐次坐标：将一个原本N维的向量用一个N+1的向量表示。

旋转：

[![xVTVd1.png](https://s1.ax1x.com/2022/09/26/xVTVd1.png)](https://imgse.com/i/xVTVd1)

在x、y、z轴上分别旋转20°、30°、15°。C向量一次乘以三个旋转矩阵。c×Mx×My×Mz=c′

[![xVTNJf.png](https://s1.ax1x.com/2022/09/26/xVTNJf.png)](https://imgse.com/i/xVTNJf)

任意轴上的旋转，n为缩放方向，k为缩放系数。

#### 齐次坐标的平移矩阵

齐次矩阵增加一个维度表示平移操作

[1,0,0,0]

[0,1,0,0]

[0,0,1,0]

[x,y,z,1]

用xyz上的切变表示在xyz轴上的偏移。

#### 四元数

欧拉角：欧拉角的表示形式是，分别沿x、y、z轴旋转度数。可能会导致万向锁（一个轴和另一个轴重叠）

几何意义：四元数有三个虚部i、j、k。q=w+i × X + j × Y + k × Z，满足i×i=j×j=k×k=-1i×j=k，ji=-kj×k=i，k×j=-ik×i=j，i×k=-j

*“四元数可解释为角位移的轴一角方式。什么是轴一角？绕某个单一轴旋转一个角位移就能表达旋转的方式称为轴一角。角位移就是一个与向量类似的表达方式，即（x，y，z），只不过四元组是用4个元素来表达。四元组可以理解为绕某个轴N旋转的角位移，与欧拉角用x、y、z表达绕标准坐标轴旋转的道理相同，只是这个轴不再是标准轴，而是任意轴。”*

A′=[cos(-A/2)，sin(-A/2)×1，0，0]

B′=[cos(-B/2)，0，sin(-B/2)×1，0]

C′=[cos(-C/2)，0，0，sin(-C/2)×1]

这表示的是三个供旋转的四元数，在X轴上旋转A度，在Y轴上旋转B度，在Z轴上旋转C度。

### 9.2 渲染管线

OpenGL；DirectX

CPU->渲染引擎或引擎的渲染组件->OpenGL/DX->显卡驱动->GPU（模板、深度、顶点缓存、纹理等）

DrawCall：CPU传送一个渲染指令的过程

渲染流水线的几个阶段

- 应用阶段（包围盒裁切、剔除、裁剪算法）：简单可以理解为引擎阶段，在这个阶段实例化模型、UI等、在这个阶段引擎会知道需要渲染哪些模型，场景内有哪些光源，相机位置，做一些裁切算法（比如视锥剔除）等。这个阶段是准备渲染数据的阶段，为下一阶段提供渲染数据依据，在这之后，向GPU提交渲染数据，它们会被复制到显存中（对于移动平台，是内存）
- 几何阶段（顶点着色器、细分着色器、几何着色器等、图元装配）：将需要绘制的图元（三角形，点线面）转换到屏幕空间。该阶段会有如下几个流程：
  1. **顶点着色器**，可编程部分，也可以在此阶段做一些shader效果和计算。
  2. 细分着色器，非必要，有些移动平台GPU不具备该功能。它包括曲面细分着色器和细分计算着色器，增加顶点和面片数量来让模型更加平滑（比如汽车在雪地行驶后留下的车轮痕迹）。几何着色器允许增加和创建新的图元。
  3. 图元装配，将顶点和相关图元组织（关联）起来，为下一步裁切做准备。
  4. 顶点变换，顶点坐标从模型空间变换到投影空间（projection space）（模型空间->世界空间->视口空间->投影空间），然后经过透视除法变换到NDC空间， 这是为了帮助裁切、深度缓冲和深度测试。
  5. 裁切，在范围内的的三角形会继续传递到下一阶段，不在的丢弃，部分在的做切割处理，将范围外的丢弃。
- 光栅化（片元着色器）：三角形设置将所有的三角形都铺在屏幕上，这样知道了三角面在屏幕上的位置和颜色情况（一个三角面占了多少像素）。三角形遍历通过计算三角三条边的位置得到覆盖的像素点，再通过三个顶点中信息做插值得到每个像素的信息，比如颜色、深度、坐标等。**片元着色器**，可编程阶段，可以将这个阶段的图元信息看成每个像素点，但它包含的信息要比像素点多，这是通过三角形遍历得到的。
- 逐片元操作：输出合并阶段（DX），包含剪切测试，多重采样，模板测试，深度测试，混合等。他们都是以片元为基础进行的操作。如果片元没有通过之前的测试，那么管线会在这时丢弃它们，如果通过就进入frame buffer等待画到屏幕上。大部分这些测试和操作都是以开关的形式存在的，在混合阶段片元会与当前frame buffer中的内容进行混合，一个典型场景就是半透明物体。
- 输出

## 第十章-渲染原理和知识

### 10.1 渲染队列

深度测试的最大好处在于，可以尽早法线不需要渲染的片元，及时抛弃以节省GPU开销。通常情况下使用LEqual做深度测试的检查条件（离相机越近的物体越会遮挡前面的物体），那么离相近越近的物体放在前面渲染，是不是可以最大程度的在该阶段节省性能呢？

Unity对所有不透明物体在渲染的时候都做了排序，离相机越近越先渲染（RQ中位置靠前），**但是这样没有办法处理半透明物体**

因为半透明物体需要做混合，混合需要不透明物体先渲染完成，因此半透物体被安排在RQ的最后，半透明物体通常不写入深度（ZWrite Off），否则半透明物体将在深度测试时抛弃比它深度高的像素。

半透明物体RQ排序方法和不透明物体一样，只不过离相机越远的物体越先渲染。

Unity中的渲染队列层次

- Background：1000
- Geometry：2000（不透明）
- AlphaTest：2450
- Transparent：3000（半透明）
- Overlay：4000

````glsl
SubShader
{
    Tags{"Queue" = "Transparent"}//在shader中指定顺序
    Pass
    {
        //...
    }
}
````

在Unity中2500以下的从近到远，2500以上的，由远到近。

### 10.2 透明测试

AlphTest使用纹理中的alpha值来决定该片元是否会被clip

````glsl
Pass
{
    //片元着色器中对片元进行clip
    half4 frag(v2f i) : SV_Target
    {
        half4 color = Tex2D(_MainTex,i.uv);
        clip(color.a - _CutOff);
        return color;
    }
}
````

### 10.3 Early-Z

在流水线中，深度测试是在片元着色器之后的阶段，因此一些本来不会通过深度测试的片元也经历了片元着色器的计算，如果折叠片元比较多，就会造成计算性能浪费。Early-Z就是为了解决这种情况。

它会在光栅化之后，片元着色器之前做一次深度测试，如果失败就认为是被遮挡的像素，直接跳过片元着色器，节省计算性能。

但无论是否失败，片元都会进入深度测试，在这个阶段决定片元去留。换句话说，Early-Z只是决定了片元是否跳过片元着色器。

Early-Z是通过GPU自动调用实现的。这里涉及到两个Pass，第一个pass写入深度缓冲（不写入像素缓存），第二个pass关闭深度写入开启深度测试。

*“由于Alpha Test的做法让我们在片元着色器中可以自主抛弃片元，因此问题又出现了。片元在着色器中被主动抛弃后，Early-Z前置深度测试的结果就会出现问题，因为测试通过的可见片元被抛弃后，被它遮挡的片元就成为可见片元，导致前置深度测试的结果出现问题。因此GPU在优化算法中，对片元着色器抛弃片元和修改深度值的操作做了检测，如果检查到片元着色器中存在抛弃片元和改写片元深度的操作，则Early-Z将被放弃使用。”*

### 10.4 MipMap

